Big Picture
--------------------------------------------------------------------------------

- What are the contributions?
  (Review C)
  * Spectrum of soundness is new, lifting it out of the folklore
  * A systematic transient
  * Apples-to-apples comparison
  * 

- Why soundness?
  (Review C)

- "This paper is beautifully written" (Review B)
  "This paper is carefully written and is well-positioned in comparison to
  related work." (Review D)
  Insulting.


- This is a PLDI-brand paper!


Review #99A
--------------------------------------------------------------------------------

#### (paper summary) misunderstanding, locally-defensive checks

> This paper particularly considers five different embeddings, including ...
> the locally-defensive embedding, which removes many unnecessary runtime checks
> from natural embedding through a static analysis.

No! The checks that get removed are not "unnecessary" in general.
They are only unnecessary for proving a certain, weak soundness theorem.


#### do you have new observations / insights?

> This paper talks about three reasons: checking, indirection, and allocation,
> which are, however, have already been observed. The idea in this paper
> thus looks more like developing a theoretical understanding of yet observed,
> practical phenomena. This is useful, too, of course.


#### is the peformance improvement interesting?

> the paper claims that "we thus consider these results a first step toward the creation
> of a feasible, sound migratory type system". While the locally-defensive embedding
> in this paper improves the performance of the natural embedding by about a magnitude, 
> the recent work by Pycket has already achieved this.

> Also, the transient strategy of ensuring type soundness exhibits much more
> competitive performance.

> Maybe transient typed Racket would be a good direction to make gradual typing
> (migratory typing) for Racket more feasible? 

Locally-defensive Racket _is_ transient typed Racket.

We did not use the name "transient" because it conflates three ideas:
 (1) forgetting certain type casts;
 (2) only checking type-tags, rather than types; and
 (3) implementing checks with locally-defensive tests instead of proxies.


#### combine embeddings? further improve locally-defensive?

> Finally, I would like to see a discussion about how to stack the three different
> optimization opportunities on each other. For example, how hard it is to implement
> the idea of the forgetful and co-natural embeddings on top of locally-defensive 
> embedding. Since the paper views the locally-defensive embedding as the most
> promising way to implement sound Typed Racket, it is important to know if we
> can make further significant performance improvement of it to make sure this
> direction leads to a "feasible, sound migratory typing".


#### questions for authors

> How hard is it to integrate co-natural and forgetful embeddings into the
> current prototype for locally-defensive embedding?


#### minor points

> Line 153, why parentheses around dyn $\tau$ e?

To clearly separate the code from the prose.
(There should be parentheses around stat $\tau$ e as well)


> Line 360, v should $v \colon \tau$.

Yes.


> Line 362, could you please provide an example expression such that
> e is well typed and reducing it is divergent?

No.
We could prove a stronger theorem (that L_S is strongly normalizing),
 but this is orthogonal to the main point of the paper.


> Figure 4, what is the meaning of $A \notin e'$? Did you mean A is not 
> a TagError and BoundaryError in the first occurrence and A is not a 
> BoundaryError in the second occurrence? In particular, what does 
> $e'$ bind to? Please clarify.

Yes, we mean that A is not a TagError and BoundaryError.
There is a typo here: `e'` should be `e`.
By `e` we mean the set of expressions defined by the grammar at the top of figure 4.


Review #99B
--------------------------------------------------------------------------------

#### what are the contributions

> My overall criticism of the paper is that I did not find much in terms of novel
> contributions. It is more of a "pearl."

> The main result is a confirmation that the transient semantics of Vitousek
> (POPL 2017) is indeed better-performing than the usual semantics with eager
> casts. This is hardly surprising given the experiments in that paper.

> The other claimed contribution is the idea that there is in fact a spectrum of
> soundness and performance: but this has been previously explored in the work on
> like types, at least.

We cite like types.


> Finally, neither the ideas around or the formalizations of the various
> implementation choices are new: described in a uniform framework, they are
> expositions of previously known approaches.


Review #99C
--------------------------------------------------------------------------------

#### is locally-defensive novel?

> There is perhaps another contribution: the idea of "locally-defensive"
> embedding.


#### locally-defensive is poorly explained

> The other frustrating thing about the locally-defensive embedding is that I
> never really understood it.
> In section 7, for the first
> time, we get a useful statement of the properties of the locally-defensive
> solution ("eventually will show an error") but it is brief and cryptic.

I can't believe the soundness theorem wasn't helpful to you.


#### measurements are not conclusive

> hard to know what to conclude about absolute speedups when so much depends on
> the constant factors, and may be dramatically affected by decent compilation.

> For example, perhaps a simple static analysis of a natural embedding could
> remove many checks.


#### proofs?

> There are theorems in the paper, but no proofs.  Can we assume that proofs
> exist?  Are they typeset somewhere?


#### gradual profiler

> I'd have thought that a helpful application of your
> framework would be to identify hot-spots: values that move to and fro a lot, or
> "if you just make this bit of code statically checked, then your whole program
> would run faster".   A kind of gradual profiler.  You have the machinery in
> hand... and it'd be useful

It's a good idea.
We are working on it.


#### minor comments

> Lines 245-250, The last para before 3.1, about the meta function that lifts a
> notion of reduction, was pretty obscure.  I read it several times, but never
> really "got it".

> Line 256 "..if it contains no free variables".  No: if al the free variables of
> e are bound by \Gamma.

line 265 "...representative of subset types that do not have a matching low
level type tag".  I have no idea what this means.

line 380 "...definition of LM  does not include a semantics".  What does it
mean to "include a semantics".  By "a semantics" I think you mean a definition
of R and R'.

(Incidentally, why use R and R' for static and dynamic rather than R^S and R^D?
I kept stumbling over which was which.) Line 284. I have not clue what the
bow-tie thing is doing.  It did not seem to be used subsequently.

3.6 (co-natural) and 3.7 (forgetful).  co-natural affects semantics (line 655)
but I believe that forgetful does not.  Correct?  Please say so.    The
type-safety theorems have an identical form in each case (same in 3.5) so it'd
be helpful to have a formal statement of how they differ!  Perhaps, if the
natural embedding converges to a value then the co-natural one does too, and to
the same value?


Sub-Review #99C
--------------------------------------------------------------------------------

#### what are the 5 soundnesses?

> The authors claim at least 5 different soundness
> conditions (line 1284), do these correspond to the 5 languages (LE,
> LN, LC, LF, LK)?


#### 3 have the same soundness

> From my understanding 3 of them have the same
> soundness condition (based on 'The language LF satisfies the same
> notion of soundness as the co-natural LC and the natural LN' (line
> 747).


#### compare the embeddings

> Perhaps a table that captures the differences between each language would be
> nice.

#### minor comments

> Line 70: 'By comparison, industrial implementations ... they do not
> insist on type soundness'. Maybe some clarification of these
> languages. I'm unsure if they mean languages like TypeScript, that are
> unsound because they insert no run-time checks at all. If so, calling
> them gradual typing rather than optional typing could be misleading. I
> think the authors see optional typing as just being at the very
> beginning of the gradual typing spectrum (rather than a separate
> entity), but I think it would be good to explicitly say this. If they
> had something else in mind it would still be useful to cite it.

> Line 648: Should Theorem (L_C type safety) read type soundness?

yes

> Line 703 till end of paragraph: I feel this could have more
> explanation; the result that you can forget all but one monitor isn't
> immediately obvious. An example would be great. In the cited work [14]
> (https://arxiv.org/pdf/1410.2813.pdf section 4.) there is a rule that
> collapses casts:
> 
> A => B: (B => C: M) for terms M, types A,B,C, collapses to A => C: M.
> 
> which makes sense because you never really need the B, it just passes
> through. This doesn't come across as clearly in this presentation.


> Line 1003: The paragraph on universal types might benefit from more
> detail. Are they supporting parametric polymorphism? I'm not convinced
> that it is possible to enforce parametricity with the monitor-free,
> tagging semantics. For example: (\x -> 42) 42, and (\x -> x) 42. I
> don't think tags can distinguish these two cases; only one has
> the type \forall X. X -> X.

No parametric polymorphism.
That is a difficult problem.

> Line 1023: 'By contrast, we view the co-natural and forgetful embeddings as
> theoretical artifacts.' I have 2 possible queries to the
> view that the co-natural embedding (lazily traversing pairs to check
> them) is just a theoretical artifact. 1) In some languages
> (JavaScript) traversing an object and accessing fields can cause side
> effects through getter/setter functions. To preserve semantics you are
> forced to only check them when the original program checks them
> (lazily). 2) Adding monitors to pairs (or records, or objects) can
> introduce problems of interference by changing identity.  I don't
> think excluding co-natural from comparison is detrimental, it's fine
> to leave it as future work. But I do think it is a concern for
> practitioners and shouldn't be portrayed as just a technical detail.

Review #99D
--------------------------------------------------------------------------------

#### work is incremental, contribution is unclear

> the work is incremental -- the authors themselves mention a lot of related
> work, for example, "Gradual typing performance" on pg. 12. However, just like
> with some other mentioned related work, they fail to clearly accentuate the
> differences between that work and this paper.  Given that, and the work under
> "Spectrum of type soundness", it is a little tough to claim as much novelty
> here.

#### small evaluation

> the scope and scale of evaluation is small

#### no user studies

> no input from actual developers is ever collected (user studies, observations
> via check-ins, etc.) so it is quite difficult to hypothesize both the amount
> of labor that goes into annotations and the demands in terms of acceptable
> overhead.

All 5 embeddings use the same static type checker / impose the same annotation burden.


> Lastly, the level of difficulty that's involved in pipointing a
> type violation is also hard to measure -- very much depends on the size and
> structure of the program




#### how to select D in practice?

> I like the notion of D-deliverable configurations from [27], however, no
> guidance is given for selecting D in practice even for the small and simple
> benchmarks that you show

I don't think you understand the notion


Review #99E
--------------------------------------------------------------------------------

#### weaknesses

> The paper does not apply these approaches to the object-oriented features of
> Racket, which are the source of the most significant performance degradations
> during gradual typing. 

> The residual costs are still high enough that they might preclude adoption.  

We said this was a first step.


#### minor points

> Figure 1. What does the notation "A not in e" mean in the side condition of the
> evaluation rule for E[e] evaluating to A? 

e is a set


> Figure 4.  How does the dynamic language know the type of the context into
> which e is being embedded?

It doesn't know (and it doesn't need to know).

This is what the syntax `(dyn t e)` is for.


> Figure 4.  Explain the notation-in-box "inherits" judgement: notation. 

Cite "Inheritance is not subtyping" ?


> Line 461.  What are category I and category II disasters? 

These are not technical terms, we just wanted to have fun.
category I is "bad", "category II is "more bad"


> Line 463.  Do you mean for the second type in the pair to be Nat when the
> professor said it was the first element that was non-negative or the other way
> around?  I believe the point you are trying to make, but I'm not following the
> specific example. 

Yes, our mistake


> Line 685.  Could you cache the result of a successful check so the cost for all
> but the first check would be negligible? 

Yes.
(See this is great, once we have these models we can talk about improving!)

> Line 705.  This sentence doesn't make sense. 

Yes.
The sentence is missing the phrase "combines the".


> Line 904.  Can you give an example of a well-typed term that isn't well-tagged
> with the corresponding tag?

`(fst (1, 1))`


> Line 1046. My understanding is that the overhead for the natural embedding is
> much higher for the object-oriented portion of TypedRacket.  Do you anticipate
> the locally-defensive approach will help in that setting?

Yes.
Section 4.2 suggests "fields exist?" as the tag check.
This check is much simpler than wrapping the object in a proxy.
