ICFP '18 Paper #21 Author Response
===========================================================================
Paper #21 A Spectrum of Soundness and Performance


General Response
===========================================================================

- Thank you all for the comments.
- Lots of places we can clarify related work.
  - stw PLDI 2015
- Review B raises serious questions 
  * Kuhlenschmidt
  * Chung
  * Vitousek


Response to Review #21A
===========================================================================

> A weak part of the paper---which is easy to fix---is that there is no
> discussion of mixed-semantics languages.  As such, Dart is badly characterized
> in this paper as an optional/erasure style language.

We will improve the discussion of Dart.
Mixed-semantics is where we plan to go next with this work.

TODO


> Additionally, because the paper mentions universal types, it seems necessary to
> explicitly clarify (maybe as a footnote) that the discussion of type soundness
> elaborated in this work is syntactic; for migratory/gradual typing to ensure (a
> form of) relational parametricity for universal types is another level of
> complexity, and a very active field of research.

Yes, definitely.


> - In Figure 4, there is quite some redundancy between ->^*_{S-N} and
>   ->^*_{D-N}: would it be possible to further factor out the common parts?

We tried factoring the common parts into a meta-function, but decided it was
better to be simple and clear.


> - Please explain why errors do not propagate through E^\bullet contexts

Errors do propagate through ---- E^\bullet is a subset of E.


> - In Theorem 2.0, 2nd reduction alternative, I don't understand why the right
>   hand side cannot be simply: E[dyn t' E* [TagErr]], considering that e' steps
>   to TarErr and that the reduction relation admits reduction under E*.
> (same question for Theorem 2.6)

YES THANK YOU, much simpler.

TODO double-check


> - (l338) "A similar lemma does not hold": would help to state the lemma that
> does not hold (there is space).

Thank you, we will elaborate.


> - The data of Figure 12 could be plotted (again, there is space)

Good point. This table is easy to miss!


> - The discussion of the gradual guarantee in section 5 is a bit incomplete.

Thank you, we will fix the discussion.


Response to Review #21B
===========================================================================

> + The paper does a thorough and controlled performance experiment that
>   confirms that the results of Vitousek et al. (2017) on Reticulated
>   Python carry over to the setting of Typed Racket. That is, the
>   transient semantics avoids the catastrophic performance problems
>   that occur in naive implementations of the natural approach, but
>   transient incurs overhead in statically typed code.

Remarks like this are exactly why we prepared this paper. We are tired of
seeing claims that make generalizations over different languages with
different type systems and different guarantees.


> * The semantic framework is a straightforward adaptation of
>   the Matthews-Findler multi-language semantics.

The first sentence of Section 2.2 and first paragraph of Section 6
(the conclusion) acknowledge Matthews & Findler. If this is not enough
acknowledgement, let us know and we can add more.


> * Theorem 2.0 is a just a combination of the usual Type Safety theorem
>   for gradually typed languages (Siek and Taha 2006) and the Blame
>   Theorem (Tobin-Hochstadt and Felleisen 2006, Wadler and Findler
>   2009). The paper does not discuss these relationships.

The novelty of the theorems is that it shows how 2 approaches to migratory
typing lead 

1. we will clarify
2. \vdash different from \vdash_N ! if you don't expose proxies, surface vs. core
3. soundness for a pair

TODO double-check


> * Theorems 2.1, 2.3, and 2.4 are all the usual type safety theorem for
>   dynamically typed languages.

Point 2 still holds --- proxies in the core language.

But right the point of these is not something novel, but to contrast

You are right that all this is _implied_ by the earlier work on gradual typing.
But somehow over the past 10 years we moved from implications to a "type soundness"
theorem published in Vitousek et al. 2017 that is fundamentally different from
a standard type soundness theorem. What happened? I don't know but I think
its a result of glossing over details like this.

TODO


> * Theorem 2.5 is just type safety for a statically typed program, and
>   is a corollary of the equivalence between gradual typing and static
>   typing on fully annotated programs (Siek et al. 2015).  The paper
>   does not discuss this close relationship.

Thank you, we will discuss the relationship.

(This may be a good point in the paper to qualify our remark in the introduction
 about soundness for a single language vs. soundness for a pair.)


> * Theorem 2.6 is an adaptation of Corollary 5.5.1 (Type soundness) of
>   Vitousek et al. (2017).  The paper does not discuss this close
>   relationship.

No, Theorem 2.6 is not just an adaptation of Vitousek et al.'s "type soundness".
Their Corollary 5.5.1 is about a single language.

You might argue that our Theorem 2.6 is just an adaptation of Vitousek et al.'s
Theorem 5.5 (Open-World Soundness), but there are three important differences:

- Vitousek et al. do not define a type system for the surface language;
  it is impossible to reason about programs independent of their core-language
  translation (via Vitousek's \rightsquigarrow)

- Vitousek et al.'s "stuck terms" are defined in terms of the core language;
  it is not clear that evaluation can only get stuck in the context.


> * Theorem 2.7 should be another example of the usual type safety
>   theorem for a dynamically typed language, but it looks like there
>   is a typo in saying |-_{LD} v : \lfloor \tau \rfloor
>   because there is no \tau to refer to here.

Thank you, that is definitely a typo.


> p1. The abstract is much too short.

The abstract says just what we choose it to say --- nothing more.

Please let us know if there is something that NEEDS to be in the abstract and
cannot wait until the introduction.


> p1. "But, it may impose a huge run-time cost"
> It would be appropriate to cite recent work by Kuhlenschmidt et
> al. (see above) that shows that the natural semantics does not have to
> impose a huge run-time cost.

We disagree, it would not be appropriate to cite Kuhlenschidt et al. here.
The sentence you quote is trying to communicate the **historical fact** that
the performance of the natural embedding has led researchers and implementors
to consider other alternatives.

Kuhlendschmidt et al.'s work does not change the past.


> p1. In the discussion of "type soundness", this paper should discuss
> the Blame Theorem, which provides the same guarantees that are provided
> by the theorems in this paper.

All the blame theorems we know* are guarantees about casts in an intermediate
language. Our type soundness theorems are guarantees about the results of
evaluating a surface-language term. These are different guarantees.

`*` Wadler and Findler (2009), Ahmed et al. (2011), Vitousek et al. (2017) ---
    all of which are slightly different theorems!


> p9. "Second, monitoring adds prohibitive run-time cost."
> That is only true of naive implementations. Again, see
> Kuhlenschmidt et al.

Kuhlenschmidt et al's work is not relevant here --- the sentence you quote is
summarizing the motivation for transient given in Vitousek et al. (2017).

Please let us know if you believe we have mis-represented Vitousek et al.


> p4. It is confusing to use boundary errors for both cast errors and
> for errors such as div-by-zero.

We do this to show that soundness for a pair of languages is a generalization
 of soundness for a single "Landin-style" language with some \delta functions.


> p9. "near-constant time"
> Why only "near" and not just "constant time"?

One reason is for union types. The check for `(U String Integer)` must do
at most two constructor checks.

Vitousek et. al 2017 do a near-constant time check for objects; they check
 that the incoming value binds the right fields.

TODO clarify, improve


> p10.
> Why do you perform checking of parameters in the reduction rules
> but insert all the other checks during compilation? This seems
> rather inconsistent and differs, as you later point out,
> from the implementations.

Footnote 3 (line 537) explains.


> p16.
> "This table demonstrates that for pathological examples..."
> Those examples are not pathological.

If you suggest a better word than "pathological" to describe "examples
with worst-case performance", we will consider using it.


> p17. "the implicit conjectures of the literature"
> You seem to be overlooking the performance experiments
> reported on by Vitousek et al. (2017).

Vitousek et al. (2017) do not measure the performance of programs that mix
typed and untyped code.


> p19. "The natural embedding incurs three significantly larger kinds of
> costs." You're forgetting the fourth: the natural embedding also has
> the space-efficiency problem pointed out by Herman et al. (2006),
> which also induces problems with time efficiency.

We did not forget, but you are right we need to be clearer that the cost
of allocation is unbounded in principle. (We will elaborate in Section 4.5.)


> p19. "Sound static types can eliminate the need to dispatch, thus the
> natural embedding's performance can exceed that of the erasure
> embedding"
>
> This paper does not provide empirical results regarding this claim.

See Figure 12.


Response to Review #21C
===========================================================================

> I am a little bit surprised at the fact that static typing does not
> contribute the runtime performance at all.  I would like to see the
> runtime performance on a JIT compiler or a compiler equipped with
> type-conscious optimization.

Typed Racket does do some type-conscious optimization, and Figure 12 shows
that this optimization can make a fully-typed program run faster than a
type-erased program.

Agreed though, it would be very interesting to see similar results for a
language with a type-aware JIT compiler.

